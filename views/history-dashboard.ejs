<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>TP357S History Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/styles/main.css" />
  <script src="/scripts/darkmode.js" defer></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>

    #intervalTabs {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    #intervalSelect {
      padding: 6px 10px;
      font-size: 14px;
      border-radius: 5px;
    }

  </style>
</head>
<body>
  <button class="dark-toggle" onclick="toggleDarkMode()">🌗</button>

  <div class="container">
    <div class="tabs" style="display: flex; justify-content: center;">
      <h2 style="margin: auto;">📈 TP357S Klima-Diagramme</h2> 
    </div> 

    <!-- Sensorauswahl -->
    <div id="sensorTabs" class="tabs"></div>

    <!-- Diagrammtyp Tabs -->
    <div id="metricTabs" class="tabs"></div>

    <!-- Aggregationsintervall -->
    <div class="tabs" id="intervalTabs">
      <label for="intervalSelect">🔁 Aggregationsintervall:</label>
      <select id="intervalSelect">
        <option value="1">1 Minute</option>
        <option value="5">5 Minuten</option>
        <option value="10" >10 Minuten</option>
        <option value="30"selected>30 Minuten</option>
        <option value="60">1 Stunde</option>
      </select>
    </div>

    <!-- Diagrammfläche -->
    <div class="chart-container" style="width: 100%; max-width: none;">
      <div id="mainChart" style="height: 500px;"></div>
    </div>
  </div>

  <script>
    const sensorNames = {};
    let historyData = {};
    let selectedSensor = '';
    let selectedMetric = 'vpd';
    let aggregationInterval = 10;

    const metricDefinitions = {
      vpd: '🌬️ VPD',
      leaf_vpd: '🍃 Leaf VPD',
      dew_point: '❄️ Taupunkt (°C)',
      absolute_humidity: '💧 Absolute Feuchte (g/m³)'
    };

    function fetchSensorNames() {
      fetch('/api/sensor-names')
        .then(res => res.json())
        .then(data => {
          Object.assign(sensorNames, data);
          fetchHistory();
        })
        .catch(err => console.error('Fehler beim Laden der Namen:', err));
    }

    function fetchHistory() {
      fetch('/api/history')
        .then(res => res.json())
        .then(data => {
          historyData = data;
          const ids = Object.keys(data);
          if (!selectedSensor || !historyData[selectedSensor]) {
            selectedSensor = ids[0];
          }
          renderSensorTabs(ids);
          renderMetricTabs();
          renderChart();
        })
        .catch(err => console.error('Fehler beim Laden der Historie:', err));
    }

    function renderSensorTabs(ids) {
      const tabsDiv = document.getElementById('sensorTabs');
      tabsDiv.innerHTML = '';

      ids.forEach(id => {
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = sensorNames[id] || `Sensor ${id}`;
        tab.dataset.sensorId = id;
        if (id === selectedSensor) tab.classList.add('active');

        tab.onclick = () => {
          selectedSensor = id;
          renderSensorTabs(ids);
          renderChart();
        };

        tabsDiv.appendChild(tab);
      });
    }

    function renderMetricTabs() {
      const metricTabs = document.getElementById('metricTabs');
      metricTabs.innerHTML = '';

      Object.entries(metricDefinitions).forEach(([key, label]) => {
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = label;
        tab.dataset.metric = key;
        if (key === selectedMetric) tab.classList.add('active');

        tab.onclick = () => {
          selectedMetric = key;
          renderMetricTabs();
          renderChart();
        };

        metricTabs.appendChild(tab);
      });
    }

    function aggregateByInterval(data, metric, intervalMinutes = 10) {
      const grouped = {};

      data.forEach(entry => {
        const time = new Date(entry.timestamp);
        const roundedTime = new Date(Math.floor(time.getTime() / (intervalMinutes * 60 * 1000)) * intervalMinutes * 60 * 1000);
        const key = roundedTime.toISOString();

        if (!grouped[key]) {
          grouped[key] = { sum: 0, count: 0 };
        }

        const value = parseFloat(entry[metric]);
        if (!isNaN(value)) {
          grouped[key].sum += value;
          grouped[key].count += 1;
        }
      });

      return Object.entries(grouped)
        .map(([timestamp, { sum, count }]) => ({
          timestamp,
          avg: sum / count
        }))
        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
    }

    function renderChart() {
      const entries = historyData[selectedSensor];
      if (!entries) return;

      const aggregated = aggregateByInterval(entries, selectedMetric, aggregationInterval);

      const timestamps = aggregated.map(e => new Date(e.timestamp));
      const y = aggregated.map(e => e.avg);

      const layout = {
        title: '',
        xaxis: {
          title: 'Zeit',
          type: 'date',
          color: getComputedStyle(document.body).getPropertyValue('--text-color').trim()
        },
        yaxis: {
          title: metricDefinitions[selectedMetric],
          color: getComputedStyle(document.body).getPropertyValue('--text-color').trim()
        },
        plot_bgcolor: 'transparent',
        paper_bgcolor: 'transparent',
        margin: { t: 30, r: 20, b: 60, l: 60 }
      };

      const trace = {
        x: timestamps,
        y,
        type: 'scatter',
        mode: 'lines',
        line: { width: 2 }
      };

      Plotly.newPlot('mainChart', [trace], layout, { responsive: true });
    }

    document.getElementById('intervalSelect').addEventListener('change', (e) => {
      aggregationInterval = parseInt(e.target.value, 10);
      renderChart();
    });

    fetchSensorNames();
    setInterval(fetchHistory, 60000);
  </script>
    <div class="button-bar">
      <button type="button" onclick="location.href='/chart'">📈 Bodenfeuchte-Diagramm</button>
      <button type="button" onclick="location.href='/moisture-data'">💧 Bodenfeuchte-Datenbank</button>
      <button type="button" onclick="location.href='/log'">📜 Logbuch</button>
      <button type="button" onclick="location.href='/system-status'">🩺 System-Status</button>
      <button type="button" onclick="location.href='/stats'">🔢 Bewässerungs-Zähler</button>
      <button type="button" onclick="location.href='/sensordata'">🌡️💧 Temperatur-Feuchtigkeits-Diagramme</button>
      <button type="button" onclick="location.href='/shelly-control'">🌱 Klima-Automatisierung</button>
      <button type="button" onclick="location.href='/relay-cycle'">🌬️ Umluft-Automatik</button>
      <button type="button" onclick="location.href='/rulelog'">Regel-Log</button>
      <button type="button" onclick="location.href='/ui'">Zur Übersicht</button>
    </div>
  </body>
</body>
</html>
