<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>TP357S History Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/styles/main.css" />
  <script src="/scripts/darkmode.js" defer></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    #intervalTabs {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    #intervalSelect {
      padding: 6px 10px;
      font-size: 14px;
      border-radius: 5px;
    }

    .tab-wrapper {
      display: inline-flex;
      align-items: center;
      margin-right: 6px;
      position: relative;
    }

    .name-input {
      padding: 4px 8px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid var(--border-color, #ccc);
      background: var(--bg-color, #fff);
      color: var(--text-color, #000);
    }

    .save-btn {
      margin-left: 6px;
      padding: 4px 8px;
      font-size: 14px;
      cursor: pointer;
      background: #28a745;
      border: none;
      color: white;
      border-radius: 4px;
    }

    .tab.dragging {
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <button class="dark-toggle" onclick="toggleDarkMode()">ğŸŒ—</button>

  <div class="container">
    <div class="tabs" style="display: flex; justify-content: center;">
      <h2 style="margin: auto;">ğŸ“ˆ TP357S Klima-Diagramme</h2>
    </div>

    <!-- Sensor-Tabs mit Umbenennung + Drag & Drop -->
    <div id="sensorTabs" class="tabs"></div>

    <!-- Diagrammtyp-Tabs -->
    <div id="metricTabs" class="tabs"></div>

    <!-- Intervallauswahl -->
    <div class="tabs" id="intervalTabs">
      <label for="intervalSelect">ğŸ” Aggregationsintervall:</label>
      <select id="intervalSelect">
        <option value="1">1 Minute</option>
        <option value="5">5 Minuten</option>
        <option value="10">10 Minuten</option>
        <option value="30" selected>30 Minuten</option>
        <option value="60">1 Stunde</option>
      </select>
    </div>

    <!-- Hauptdiagramm -->
    <div class="chart-container" style="width: 100%; max-width: none;">
      <div id="mainChart" style="height: 500px;"></div>
    </div>
  </div>

  <script>
    const sensorNames = {};
    let historyData = {};
    let selectedSensor = '';
    let selectedMetric = 'vpd';
    let aggregationInterval = 10;

    const metricDefinitions = {
      vpd: 'ğŸŒ¬ï¸ VPD',
      leaf_vpd: 'ğŸƒ Leaf VPD',
      dew_point: 'â„ï¸ Taupunkt (Â°C)',
      absolute_humidity: 'ğŸ’§ Absolute Feuchte (g/mÂ³)'
    };

    function fetchSensorNames() {
      fetch('/api/sensor-names')
        .then(res => res.json())
        .then(data => {
          Object.assign(sensorNames, data);
          fetchHistory();
        })
        .catch(err => console.error('Fehler beim Laden der Namen:', err));
    }

    function fetchHistory() {
      fetch('/api/history')
        .then(res => res.json())
        .then(data => {
          historyData = data;
          const ids = Object.keys(data);
          if (!selectedSensor || !historyData[selectedSensor]) {
            selectedSensor = ids[0];
          }
          renderSensorTabs(ids);
          renderMetricTabs();
          renderChart();
        })
        .catch(err => console.error('Fehler beim Laden der Historie:', err));
    }

    function renderSensorTabs(sensorIds) {
      const tabsDiv = document.getElementById('sensorTabs');
      tabsDiv.innerHTML = '';

      const savedOrder = JSON.parse(localStorage.getItem('sensorTabOrder') || '[]');
      if (savedOrder.length) {
        sensorIds.sort((a, b) => savedOrder.indexOf(a) - savedOrder.indexOf(b));
      }

      sensorIds.forEach(id => {
        const wrapper = document.createElement('div');
        wrapper.className = 'tab-wrapper';
        wrapper.setAttribute('draggable', 'true');
        wrapper.dataset.sensorId = id;

        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = sensorNames[id] || `Sensor ${id}`;
        tab.dataset.sensorId = id;
        if (id === selectedSensor) tab.classList.add('active');

        tab.onclick = () => {
          selectedSensor = id;
          renderSensorTabs(sensorIds);
          renderChart();
        };

        // Rechtsklick fÃ¼r Umbenennung
        tab.addEventListener('contextmenu', e => {
          e.preventDefault();
          const input = document.createElement('input');
          input.type = 'text';
          input.value = sensorNames[id] || `Sensor ${id}`;
          input.className = 'name-input';

          const saveBtn = document.createElement('button');
          saveBtn.className = 'save-btn';
          saveBtn.textContent = 'Speichern';
          saveBtn.onclick = () => {
            const newName = input.value.trim();
            if (newName) saveSensorName(id, newName);
          };

          wrapper.innerHTML = '';
          wrapper.appendChild(input);
          wrapper.appendChild(saveBtn);
        });

        wrapper.appendChild(tab);
        tabsDiv.appendChild(wrapper);

        // Drag & Drop
        wrapper.addEventListener('dragstart', e => {
          wrapper.classList.add('dragging');
          e.dataTransfer.setData('text/plain', id);
        });

        wrapper.addEventListener('dragend', () => {
          wrapper.classList.remove('dragging');
          const newOrder = Array.from(tabsDiv.children).map(el => el.dataset.sensorId);
          localStorage.setItem('sensorTabOrder', JSON.stringify(newOrder));
        });

        wrapper.addEventListener('dragover', e => {
          e.preventDefault();
          const dragging = document.querySelector('.dragging');
          if (dragging && dragging !== wrapper) {
            const bounding = wrapper.getBoundingClientRect();
            const offset = e.clientY - bounding.top;
            if (offset < bounding.height / 2) {
              tabsDiv.insertBefore(dragging, wrapper);
            } else {
              tabsDiv.insertBefore(dragging, wrapper.nextSibling);
            }
          }
        });
      });
    }

    function saveSensorName(id, newName) {
      fetch('/api/sensor-names', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, name: newName })
      })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            sensorNames[id] = newName;
            renderSensorTabs(Object.keys(historyData));
            renderChart();
          } else {
            alert('Fehler beim Speichern.');
          }
        })
        .catch(err => {
          console.error('Speicherfehler:', err);
          alert('Speichern fehlgeschlagen.');
        });
    }

    function renderMetricTabs() {
      const metricTabs = document.getElementById('metricTabs');
      metricTabs.innerHTML = '';

      Object.entries(metricDefinitions).forEach(([key, label]) => {
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = label;
        tab.dataset.metric = key;
        if (key === selectedMetric) tab.classList.add('active');

        tab.onclick = () => {
          selectedMetric = key;
          renderMetricTabs();
          renderChart();
        };

        metricTabs.appendChild(tab);
      });
    }

    function aggregateByInterval(data, metric, intervalMinutes = 10) {
      const grouped = {};

      data.forEach(entry => {
        const time = new Date(entry.timestamp);
        const roundedTime = new Date(Math.floor(time.getTime() / (intervalMinutes * 60 * 1000)) * intervalMinutes * 60 * 1000);
        const key = roundedTime.toISOString();

        if (!grouped[key]) {
          grouped[key] = { sum: 0, count: 0 };
        }

        const value = parseFloat(entry[metric]);
        if (!isNaN(value)) {
          grouped[key].sum += value;
          grouped[key].count += 1;
        }
      });

      return Object.entries(grouped)
        .map(([timestamp, { sum, count }]) => ({
          timestamp,
          avg: sum / count
        }))
        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
    }

    function renderChart() {
      const entries = historyData[selectedSensor];
      if (!entries) return;

      const aggregated = aggregateByInterval(entries, selectedMetric, aggregationInterval);
      const timestamps = aggregated.map(e => new Date(e.timestamp));
      const y = aggregated.map(e => e.avg);

      const layout = {
        title: '',
        xaxis: {
          title: 'Zeit',
          type: 'date',
          color: getComputedStyle(document.body).getPropertyValue('--text-color').trim()
        },
        yaxis: {
          title: metricDefinitions[selectedMetric],
          color: getComputedStyle(document.body).getPropertyValue('--text-color').trim()
        },
        plot_bgcolor: 'transparent',
        paper_bgcolor: 'transparent',
        margin: { t: 30, r: 20, b: 60, l: 60 }
      };

      const trace = {
        x: timestamps,
        y,
        type: 'scatter',
        mode: 'lines',
        line: { width: 2 }
      };

      Plotly.newPlot('mainChart', [trace], layout, { responsive: true });
    }

    document.getElementById('intervalSelect').addEventListener('change', (e) => {
      aggregationInterval = parseInt(e.target.value, 10);
      renderChart();
    });

    fetchSensorNames();
    setInterval(fetchHistory, 60000);
  </script>

  <!-- Navigation -->
  <div class="button-bar">
    <button type="button" onclick="location.href='/chart'">ğŸ“ˆ Bodenfeuchte-Diagramm</button>
    <button type="button" onclick="location.href='/moisture-data'">ğŸ’§ Bodenfeuchte-Datenbank</button>
    <button type="button" onclick="location.href='/log'">ğŸ“œ Logbuch</button>
    <button type="button" onclick="location.href='/system-status'">ğŸ©º System-Status</button>
    <button type="button" onclick="location.href='/stats'">ğŸ”¢ BewÃ¤sserungs-ZÃ¤hler</button>
    <button type="button" onclick="location.href='/sensordata'">ğŸŒ¡ï¸ğŸ’§ Temperatur-Feuchtigkeits-Diagramme</button>
    <button type="button" onclick="location.href='/klima-control'">ğŸŒ± Klima-Automatisierung</button>
    <button type="button" onclick="location.href='/relay-cycle'">ğŸŒ¬ï¸ Umluft-Automatik</button>
    <button type="button" onclick="location.href='/rulelog'">Regel-Log</button>
    <button type="button" onclick="location.href='/combined-dashboard'">Combi-Dashboard</button>
    <button type="button" onclick="location.href='/ui'">Zur Ãœbersicht</button>
  </div>
</body>
</html>
