<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TP357S Sensor Dashboard</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f9;
      color: #333;
      margin: 0;
      padding: 20px;
    }
    h1 {
      color: #4CAF50;
      text-align: center;
      margin-bottom: 10px;
      font-size: 32px;
    }
    .container {
      max-width: 1000px;
      margin: auto;
      padding: 20px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 12px;
    }
    .tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    .tab {
      cursor: pointer;
      background: #eee;
      margin: 5px;
      padding: 10px;
      border-radius: 6px;
      display: inline-block;
    }
    .tab.active {
      background: #4CAF50;
      color: white;
      font-weight: bold;
    }
    .tab-wrapper {
      display: flex;
      align-items: center;
      cursor: move;
    }
    .tab-wrapper.dragging {
      opacity: 0.5;
    }
    .name-input {
      padding: 5px;
      font-size: 14px;
      width: 160px;
    }
    .edit-btn, .save-btn {
      margin-left: 10px;
      padding: 5px 10px;
      background-color: #FF9800;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 5px;
    }
    .save-btn {
      background-color: #4CAF50;
    }
    .save-btn:hover, .edit-btn:hover {
      opacity: 0.9;
    }
    #chartsContainer {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    .chart-container {
      width: 46%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background-color: #fff;
    }
    @media (max-width: 768px) {
      .chart-container {
        width: 100%;
      }
    }
    .back-btn {
      display: block;
      margin: 20px auto;
      text-align: center;
      background-color: #4CAF50;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      text-decoration: none;
      width: max-content;
    }
    .back-btn:hover {
      background-color: #45a049;
    }
    #updateTime {
      text-align: center;
      margin-bottom: 10px;
      font-style: italic;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìà TP357S Sensor Dashboard</h1>
    <a class="back-btn" href="/">Zur√ºck zur √úbersicht</a>
    <div id="updateTime"></div>
    <div id="tabsContainer" class="tabs"></div>
    <div id="chartsContainer"></div>
  </div>

  <script>
    let sensorData = {};
    let selectedSensorId = "";
    const sensorNames = {};

    const tabsContainer = document.getElementById('tabsContainer');
    const chartsContainer = document.getElementById('chartsContainer');
    const updateTime = document.getElementById('updateTime');

    // Holt die Namen aus dem Backend
    function fetchSensorNames() {
      fetch('/api/sensor-names')
        .then(res => res.json())
        .then(names => {
          Object.assign(sensorNames, names);
          createEditableTabs(Object.keys(sensorData));
        })
        .catch(err => console.error('Fehler beim Abrufen der Namen:', err));
    }

    // Holt die Sensordaten regelm√§√üig
    function fetchSensorData() {
      fetch('/api/sensordata')
        .then(res => res.json())
        .then(data => {
          sensorData = data;
          const ids = Object.keys(data);

          if (!selectedSensorId || !sensorData[selectedSensorId]) {
            selectedSensorId = ids[0];
          }

          // Nur beim ersten Mal Tabs erstellen
          if (!tabsContainer.hasChildNodes()) {
            createEditableTabs(ids);
          }

          highlightActiveTab();
          drawCharts(sensorData[selectedSensorId], selectedSensorId);
          updateTime.textContent = `Letzte Aktualisierung: ${new Date().toLocaleTimeString()}`;
        })
        .catch(err => console.error('Fehler beim Laden:', err));
    }

    // Tabs anzeigen mit Drag & Drop und Rechtsklick zum Umbenennen
    function createEditableTabs(sensorIds) {
      tabsContainer.innerHTML = '';
      const savedOrder = JSON.parse(localStorage.getItem('sensorTabOrder') || '[]');
      if (savedOrder.length) {
        sensorIds.sort((a, b) => savedOrder.indexOf(a) - savedOrder.indexOf(b));
      }

      sensorIds.forEach(id => {
        if (sensorData[id] && sensorData[id].length > 0) {
          const wrapper = document.createElement('div');
          wrapper.className = 'tab-wrapper';
          wrapper.setAttribute('draggable', 'true');
          wrapper.dataset.sensorId = id;

          const tab = document.createElement('div');
          tab.className = 'tab';
          tab.textContent = sensorNames[id] || `Sensor ${id}`;
          tab.dataset.sensorId = id;
          if (id === selectedSensorId) tab.classList.add('active');

          tab.onclick = () => {
            selectedSensorId = id;
            highlightActiveTab();
            drawCharts(sensorData[id], id);
          };

          tab.addEventListener('contextmenu', e => {
            e.preventDefault();
            const input = document.createElement('input');
            input.type = 'text';
            input.value = sensorNames[id] || `Sensor ${id}`;
            input.className = 'name-input';

            const saveBtn = document.createElement('button');
            saveBtn.className = 'save-btn';
            saveBtn.textContent = 'Speichern';

            saveBtn.onclick = () => {
              const newName = input.value.trim();
              if (newName) saveSensorName(id, newName);
            };

            wrapper.innerHTML = '';
            wrapper.appendChild(input);
            wrapper.appendChild(saveBtn);
          });

          wrapper.appendChild(tab);
          tabsContainer.appendChild(wrapper);

          // Drag & Drop
          wrapper.addEventListener('dragstart', e => {
            wrapper.classList.add('dragging');
            e.dataTransfer.setData('text/plain', id);
          });

          wrapper.addEventListener('dragend', () => {
            wrapper.classList.remove('dragging');
            const newOrder = Array.from(tabsContainer.children).map(el => el.dataset.sensorId);
            localStorage.setItem('sensorTabOrder', JSON.stringify(newOrder));
          });

          wrapper.addEventListener('dragover', e => {
            e.preventDefault();
            const dragging = document.querySelector('.dragging');
            if (dragging && dragging !== wrapper) {
              const bounding = wrapper.getBoundingClientRect();
              const offset = e.clientY - bounding.top;
              if (offset < bounding.height / 2) {
                tabsContainer.insertBefore(dragging, wrapper);
              } else {
                tabsContainer.insertBefore(dragging, wrapper.nextSibling);
              }
            }
          });
        }
      });
    }

    function highlightActiveTab() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.sensorId === selectedSensorId);
      });
    }

    function saveSensorName(id, newName) {
      fetch('/api/sensor-names', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, name: newName })
      })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            sensorNames[id] = newName;
            createEditableTabs(Object.keys(sensorData));
            drawCharts(sensorData[selectedSensorId], selectedSensorId);
          } else {
            alert('Fehler beim Speichern.');
          }
        })
        .catch(err => {
          console.error('Speicherfehler:', err);
          alert('Speichern fehlgeschlagen.');
        });
    }

    // Diagramme anzeigen und aktualisieren
    function drawCharts(entries, sensorId) {
      if (!entries || entries.length === 0) return;

      const timestamps = entries.map(d => new Date(d.timestamp));
      const temps = entries.map(d => d.temperature);
      const hums = entries.map(d => d.humidity);

      const T = temps[temps.length - 1];
      const RH = hums[hums.length - 1];
      const vpd = calcVPD(T, RH);

      // Farbe je nach VPD-Bereich
      let bgColor = '';
      if (vpd < 0.8) bgColor = 'rgba(0, 0, 255, 0.1)';
      else if (vpd > 1.35) bgColor = 'rgba(255, 0, 0, 0.1)';
      else bgColor = 'rgba(0, 255, 0, 0.1)';

      // Nur neu bauen, wenn Sensor-ID gewechselt wurde
      const chartNeedsInit = document.getElementById('tempChart')?.dataset.sensorId !== sensorId;
      if (chartNeedsInit) {
    chartsContainer.innerHTML = `
    
    <div style="width: 100%; display: flex; justify-content: flex-end;">
      <div
        id="vpdDisplay"
        title=""
        style="margin-bottom: 10px; padding: 5px 10px; background: #eee; border-radius: 6px; font-size: 13px; color: #333; cursor: help;">
        VPD: <strong>‚Äì</strong>
      </div>
    </div>
    <div class="chart-container">
      <h3>üå°Ô∏è Temperatur-Verlauf ‚Äì ${sensorNames[sensorId] || `Sensor ${sensorId}`}</h3>
      <div id="tempChart" data-sensor-id="${sensorId}"></div>
    </div>
    <div class="chart-container">
      <h3>üíß Feuchtigkeits-Verlauf ‚Äì ${sensorNames[sensorId] || `Sensor ${sensorId}`}</h3>
      <div id="humChart"></div>
    </div>
  `;
}


    // VPD-Anzeige aktualisieren (Wert UND Tooltip)
  const vpdBox = document.getElementById('vpdDisplay');
    if (vpdBox) {
    vpdBox.innerHTML = `VPD: <strong>${vpd} kPa</strong>`;
    vpdBox.title = "VPD < 0.6 = zu feucht ¬∑ 0.6‚Äì1.2 = ideal ¬∑ > 1.2 = zu trocken";
    }   


      // Temperatur-Diagramm aktualisieren
      Plotly.react("tempChart", [{
        x: timestamps,
        y: temps,
        type: 'scatter',
        mode: 'lines+markers',
        name: 'Temperatur (¬∞C)',
        line: { color: 'green', width: 3 },
        marker: { color: temps.map(t => t > 30 ? 'red' : 'green'), size: 6 }
      }], {
        xaxis: { title: 'Zeit', type: 'date', tickformat: '%d.%m.%Y %H:%M', tickangle: -45 },
        yaxis: { title: 'Temperatur (¬∞C)', range: [0, 40] },
        shapes: [{
          type: 'rect', xref: 'paper', x0: 0, x1: 1,
          yref: 'y', y0: 0, y1: 40,
          fillcolor: bgColor, line: { width: 0 }
        }],
        margin: { t: 20, r: 20, b: 60, l: 60 }
      });

      // Luftfeuchte-Diagramm aktualisieren
      Plotly.react("humChart", [{
        x: timestamps,
        y: hums,
        type: 'scatter',
        mode: 'lines+markers',
        name: 'Feuchtigkeit (%)',
        line: { color: 'blue', width: 3 },
        marker: { color: hums.map(h => h > 60 ? 'red' : 'blue'), size: 6 }
      }], {
        xaxis: { title: 'Zeit', type: 'date', tickformat: '%d.%m.%Y %H:%M', tickangle: -45 },
        yaxis: { title: 'Feuchtigkeit (%)', range: [0, 100] },
        shapes: [{
          type: 'rect', xref: 'paper', x0: 0, x1: 1,
          yref: 'y', y0: 0, y1: 100,
          fillcolor: bgColor, line: { width: 0 }
        }],
        margin: { t: 20, r: 20, b: 60, l: 60 }
      });
    }

    // VPD-Berechnung (kPa)
    function calcVPD(tempC, rh) {
      const es = 0.6108 * Math.exp((17.27 * tempC) / (tempC + 237.3));
      const ea = es * (rh / 100);
      return parseFloat((es - ea).toFixed(2));
    }

    // Initialisierung
    fetchSensorNames();
    fetchSensorData();
    setInterval(fetchSensorData, 10000); // alle 10 Sekunden
  </script>
</body>
</html>
