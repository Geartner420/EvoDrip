<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>ğŸŒ± Kombi-Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/styles/main.css" />
  <script src="/scripts/darkmode.js" defer></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
    }
    .controls label {
      display: flex;
      flex-direction: column;
      font-size: 14px;
      text-align: left;
    }
    .controls select {
      padding: 4px;
      font-size: 14px;
      min-width: 60px;
    }
  </style>
</head>
<body>
  <button class="dark-toggle" onclick="toggleDarkMode()">ğŸŒ—</button>
  <div class="container">
    <h1>ğŸŒ¡ Kombiniertes Sensor-Dashboard</h1>

    <div id="tabsContainer" class="tabs" style="text-align:center;"></div>

    <div class="controls">
      <label>
        Aggregation:
        <select id="aggSelect">
          <option value="1">1 Min</option>
          <option value="2" selected>2 Min</option>
          <option value="3">3 Min</option>
        </select>
      </label>

      <label>
        Zeitraum:
        <select id="timeWindowSelect">
          <option value="10800" selected>3 Stunden</option>
          <option value="21600">6 Stunden</option>
          <option value="43200">12 Stunden</option>
          <option value="86400">24 Stunden</option>
          <option value="604800">7 Tage</option>
        </select>
      </label>
      <label>
        GlÃ¤ttung:
        <select id="smoothingSelect">
          <option value="1">Keine</option>
          <option value="3" >3er Mittel</option>
          <option value="5">5er Mittel</option>
          <option value="10" selected>10er Mittel</option>
          <option value="15">15er Mittel</option>
          <option value="20">20er Mittel</option>
        </select>
      </label>
    </div>

    <div id="chart" style="height: 600px; margin-top: 20px;"></div>
    <div id="lastUpdate" style="margin-top: 10px; font-size: 0.9em; opacity: 0.7;"></div>
  </div>
  <script>
    let sensorData = {};
    let relayLog = [];
    let selectedSensor = '';
    let selectedSensorId = '';
    let sensorNames = {};
    let aggregationMinutes = 1;

    const updateTime = document.getElementById('lastUpdate');

    function fetchData() {
      const limit = 10000;
      Promise.all([
        fetch(`/api/sensordata?limit=${limit}`).then(r => r.json()),
        fetch('/api/relay-switches-log').then(r => r.json())
      ])
      .then(([sensors, relays]) => {
        sensorData = sensors;
        relayLog = relays;
        if (!selectedSensor || !sensorData[selectedSensor]) {
          selectedSensor = Object.keys(sensorData)[0];
          selectedSensorId = selectedSensor;
        }
        createEditableTabs(Object.keys(sensorData));
        highlightActiveTab();
        drawChart();
        fetchSensorNames();
      });
    }

    function createEditableTabs(sensorIds) {
      const container = document.getElementById('tabsContainer');
      container.innerHTML = '';
      const savedOrder = JSON.parse(localStorage.getItem('sensorTabOrder') || '[]');
      if (savedOrder.length) {
        sensorIds.sort((a, b) => savedOrder.indexOf(a) - savedOrder.indexOf(b));
      }

      sensorIds.forEach(id => {
        if (sensorData[id] && sensorData[id].length > 0) {
          const wrapper = document.createElement('div');
          wrapper.className = 'tab-wrapper';
          wrapper.setAttribute('draggable', 'true');
          wrapper.dataset.sensorId = id;

          const tab = document.createElement('div');
          tab.className = 'tab';
          tab.textContent = sensorNames[id] || `Sensor ${id}`;
          tab.dataset.sensorId = id;
          if (id === selectedSensorId) tab.classList.add('active');

          tab.onclick = () => {
            selectedSensor = id;
            selectedSensorId = id;
            highlightActiveTab();
            drawChart();
          };

          tab.addEventListener('contextmenu', e => {
            e.preventDefault();
            const input = document.createElement('input');
            input.type = 'text';
            input.value = sensorNames[id] || `Sensor ${id}`;
            input.className = 'name-input';

            const saveBtn = document.createElement('button');
            saveBtn.className = 'save-btn';
            saveBtn.textContent = 'Speichern';
            saveBtn.onclick = () => {
              const newName = input.value.trim();
              if (newName) saveSensorName(id, newName);
            };

            wrapper.innerHTML = '';
            wrapper.appendChild(input);
            wrapper.appendChild(saveBtn);
          });

          wrapper.appendChild(tab);
          container.appendChild(wrapper);

          wrapper.addEventListener('dragstart', e => {
            wrapper.classList.add('dragging');
            e.dataTransfer.setData('text/plain', id);
          });

          wrapper.addEventListener('dragend', () => {
            wrapper.classList.remove('dragging');
            const newOrder = Array.from(container.children).map(el => el.dataset.sensorId);
            localStorage.setItem('sensorTabOrder', JSON.stringify(newOrder));
          });

          wrapper.addEventListener('dragover', e => {
            e.preventDefault();
            const dragging = document.querySelector('.dragging');
            if (dragging && dragging !== wrapper) {
              const bounding = wrapper.getBoundingClientRect();
              const offset = e.clientY - bounding.top;
              if (offset < bounding.height / 2) {
                container.insertBefore(dragging, wrapper);
              } else {
                container.insertBefore(dragging, wrapper.nextSibling);
              }
            }
          });
        }
      });
    }

    function highlightActiveTab() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.sensorId === selectedSensorId);
      });
    }

    function saveSensorName(id, newName) {
      fetch('/api/sensor-names', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, name: newName })
      })
      .then(res => res.json())
      .then(data => {
        if (data.success) {
          sensorNames[id] = newName;
          createEditableTabs(Object.keys(sensorData));
          drawChart();
        } else {
          alert('Fehler beim Speichern.');
        }
      })
      .catch(err => {
        console.error('Speicherfehler:', err);
        alert('Speichern fehlgeschlagen.');
      });
    }

    function roundTimestampTo(date, minutes) {
      const ms = minutes * 60 * 1000;
      return new Date(Math.floor(date.getTime() / ms) * ms);
    }

    function aggregate(data, minutes) {
      const grouped = {};
      data.forEach(entry => {
        const key = roundTimestampTo(new Date(entry.timestamp), minutes).toISOString();
        if (!grouped[key]) grouped[key] = [];
        grouped[key].push(entry);
      });

      return Object.entries(grouped).map(([ts, group]) => {
        const avg = arr => arr.reduce((a, b) => a + b, 0) / arr.length;
        return {
          timestamp: ts,
          temperature: avg(group.map(e => e.temperature)),
          humidity: avg(group.map(e => e.humidity))
        };
      });
    }

    function movingAverage(arr, windowSize) {
      return arr.map((_, i, a) => {
        const start = Math.max(0, i - windowSize + 1);
        const window = a.slice(start, i + 1);
        return window.reduce((sum, val) => sum + val, 0) / window.length;
      });
    }
    function drawChart() {
  if (!sensorData[selectedSensor]) return;

  const data = sensorData[selectedSensor];
  const aggregationMinutes = parseInt(document.getElementById('aggSelect').value);
  const smoothing = parseInt(document.getElementById('smoothingSelect').value);
  const timeWindow = parseInt(document.getElementById('timeWindowSelect').value) * 1000;
  const now = Date.now();

  const filtered = data.filter(entry =>
    new Date(entry.timestamp).getTime() >= now - timeWindow
  );

  const aggregated = aggregate(filtered, aggregationMinutes);
  const times = aggregated.map(d => new Date(d.timestamp));
  const temps = movingAverage(aggregated.map(d => d.temperature), smoothing);
  const hums  = movingAverage(aggregated.map(d => d.humidity), smoothing);
  
  // Temperatur
  const tempMin = Math.min(...temps);
  const tempMax = Math.max(...temps);
  const tempCenter = (tempMax + tempMin) / 2;
  const tempRange = tempMax - tempMin;
  const paddedTempRange = tempRange * 1.2;
  const tempRangeFinal = [
    tempCenter - paddedTempRange / 2,
    tempCenter + paddedTempRange / 2
  ];

      const humMin = Math.min(...hums);
    const humMax = Math.max(...hums);
    const humCenter = (humMax + humMin) / 2;
    const humRange = humMax - humMin;
    const paddedHumRange = humRange * 1.2;
    const humRangeFinal = [
      humCenter - paddedHumRange / 2,
      humCenter + paddedHumRange / 2
    ];


  // Schaltzeichen an RH-Linie mit Versatz
  const rhForSwitch = hums;
  const logSensorKey = `sensor_${selectedSensor}.json`;
  const switches = relayLog
    .filter(r => r.sensor === logSensorKey && new Date(r.timestamp).getTime() >= now - timeWindow)
    .map(r => {
      const ts = new Date(r.timestamp);
      const i = times.findIndex(t => t.getTime() >= ts.getTime());
      const baseY = (i >= 0 && rhForSwitch[i] != null) ? rhForSwitch[i] : 50;
      const offsetY = r.state === 'on' ? baseY -0 : baseY -0

      return {
        x: [ts],
        y: [offsetY],
        type: 'scatter',
        mode: 'markers',
        name: `ğŸ”Œ ${r.relay} (${r.state})`,
        marker: {
          size: 10,
          symbol: r.state === 'on' ? 'triangle-up' : 'triangle-down',
          color: r.state === 'on' ? '#28a745' : '#dc3545',
          line: { width: 1, color: '#333' }
        },
        hovertemplate: `ğŸ”Œ ${r.relay} (${r.state})<br>${r.reason}<br>%{x}<extra></extra>`,
        yaxis: 'y2'
      };
    });

  Plotly.newPlot('chart', [
    {
      x: times,
      y: temps,
      name: 'ğŸŒ¡ Temperatur (Â°C)',
      type: 'scatter',
      mode: 'lines+markers',
      marker: { color: 'orange', size: 2 },
      line: { shape: 'linear' },
      hovertemplate: 'Zeit: %{x}<br>ğŸŒ¡ %{y:.2f} Â°C<extra></extra>'
    },
    {
      x: times,
      y: hums,
      name: 'ğŸ’§ Luftfeuchte (%)',
      type: 'scatter',
      mode: 'lines+markers',
      yaxis: 'y2',
      marker: { color: 'blue', size: 2 },
      line: { shape: 'linear' },
      hovertemplate: 'Zeit: %{x}<br>ğŸ’§ %{y:.2f} %<extra></extra>'
    },
    ...switches
  ], {
    xaxis: {
      title: 'Zeit',
      type: 'date',
      tickformat: '%H:%M',
      tickangle: -30
    },
    yaxis: {
      title: 'Temperatur (Â°C)',
      range: tempRangeFinal
    },
    yaxis2: {
      title: 'Luftfeuchte (%)',
      overlaying: 'y',
      side: 'right',
      range: humRangeFinal
    },
    legend: { orientation: 'h' },
    margin: { t: 40, b: 60 },
    plot_bgcolor: 'transparent',
    paper_bgcolor: 'transparent'
  });

  updateTime.textContent = `Zuletzt aktualisiert: ${new Date().toLocaleTimeString()}`;
}

    function fetchSensorNames() {
      fetch('/api/sensor-names')
        .then(res => res.json())
        .then(names => {
          Object.assign(sensorNames, names);
          createEditableTabs(Object.keys(sensorData));
        });
    }

    document.querySelectorAll('select').forEach(el => {
      el.addEventListener('change', () => {
        if (el.id === 'dataLimitSelect') {
          fetchData(); // Reload API-Daten bei Limitwechsel
        } else {
          drawChart(); // Nur Chart neu zeichnen bei den anderen
        }
      });
    });

    fetchData();
  </script>

  <div class="button-bar">
    <button type="button" onclick="location.href='/chart'">ğŸ“ˆ Bodenfeuchte-Diagramm</button>
    <button type="button" onclick="location.href='/moisture-data'">ğŸ’§ Bodenfeuchte-Datenbank</button>
    <button type="button" onclick="location.href='/log'">ğŸ“œ Logbuch</button>
    <button type="button" onclick="location.href='/system-status'">ğŸ©º System-Status</button>
    <button type="button" onclick="location.href='/stats'">ğŸ”¢ BewÃ¤sserungs-ZÃ¤hler</button>
    <button type="button" onclick="location.href='/sensordata'">ğŸŒ¡ï¸ğŸ’§ Temperatur-Feuchtigkeits-Diagramme</button>
    <button type="button" onclick="location.href='/dashboard/history'">ğŸŒ¡ï¸ğŸ’§ Klima-Diagramme</button>
    <button type="button" onclick="location.href='/klima-control'">ğŸŒ± Klima-Automatisierung</button>
    <button type="button" onclick="location.href='/relay-cycle'">ğŸŒ¬ï¸ Umluft-Automatik</button>
    <button type="button" onclick="location.href='/rulelog'">Regel-Log</button>
    <button type="button" onclick="location.href='/ui'">Zur Ãœbersicht</button>
  </div>
</body>
</html>
